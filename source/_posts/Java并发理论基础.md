---
title: Java并发理论基础
id: java-concurrent-basic-theory
date: 2020-05-18 10:23:33
updated: 2020-05-18 10:23:33
categories:
  - 人类的本质是复读机
tags:
  - 并发
---

<font color="red">**并发编程的第一原则：不要写并发程序**</font>

### 多线程并发问题

- 硬件的核心矛盾：CPU 与内存、I/O 的速度差异
- 三个核心问题：分工、同步、互斥
    - **分工**：如何高效地拆解任务并分配给线程（Fork/Join 框架就是一种分工模式）
    - **同步**：线程之间如何协作（CountDownLatch 就是一种典型的同步方式）
    - **互斥**：保证同一时刻只允许一个线程访问共享资源（可重入锁就是一种互斥手段）
- 核心矛盾：CPU、内存、I/O 设备，这三者的速度差异
- 并发编程Bug的源头：
    - 缓存导致的**可见性**问题（volatile解决）
    - 线程切换带来的**原子性**问题（锁解决）
    - 编译优化带来的**有序性**问题（happens-before解决）

### Java内存模型

- Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及八项 Happens-Before 规则。
- volatile：最原始的意义就是禁用 CPU 缓存。
- final：这个变量生而不变，可以可劲儿优化。
- happens-before：前面一个操作的结果对后续操作是可见的。
    - **程序次序规则**：一个线程内，按照代码顺序，书写在前面的操作 happens-before 书写在后面的操作。
    - **锁定规则**：一个unLock操作 happens-before 后面对同一个锁的lock操作。
    - **volatile变量规则**：对一个变量的写操作 happens-before 后面对这个变量的读操作。
    - **传递规则**：如果操作A happens-before  操作B，而操作B又 happens-before 操作C，则可以得出操作A happens-before 操作C。
    - **线程启动规则**：Thread对象的start()方法 happens-before 此线程的每个一个动作。
    - **线程中断规则**：对线程interrupt()方法的调用 happens-before 被中断线程的代码检测到中断事件的发生。
    - **线程终结规则**：线程中所有的操作都 happens-before 线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。
    - **对象终结规则**：一个对象的初始化完成 happens-before 他的finalize()方法的开始

<!-- more -->

### 锁

- 锁，一定有一个要锁定的对象。两把锁保护一个资源时，可能会有并发问题。可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源。
- 如果资源之间没有关系，很好处理，每个资源一把锁就可以了。如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。
- 锁，应是私有的、不可变的、不可重用的。
- 发生死锁的四个条件：
    - 互斥：共享资源 X 和 Y 只能被一个线程占用；        
    - 占有且等待：线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
        - 解决方法：一次性申请所有的资源
    - 不可抢占：其他线程不能强行抢占线程 T1 占有的资源；
        - 解决方法：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资资源
    - 循环等待：线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。
        -  解决方法：按序申请资源
- **用锁的最佳实践**
    - 永远只在更新对象的成员变量时加锁
    - 永远只在访问可变的成员变量时加锁
    - 永远不在调用其他对象的方法时加锁



###  wait()、notify()、notifyAll()

- 每个互斥锁都有自己独立的等待队列，线程在进入等待队列的同时，会释放持有的互斥锁
- wait()、notify()、notifyAll() 都是在 synchronized{}内部被调用的。如果在 synchronized{}外部调用，或者锁定的 this，而用 target.wait() 调用的话，JVM 会抛出一个运行时异常：java.lang.IllegalMonitorStateException。
- notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程。使用 notify() 可能导致某些线程永远不会被通知到，尽量使用 notifyAll()。
- 使用 notify() 需要满足以下三个条件：
    - 所有等待线程拥有相同的等待条件（**重点**）
    - 所有等待线程被唤醒后，执行相同的操作
    - 只需要唤醒一个线程


### 安全性、活跃性以及性能问题

- 有多个线程会同时读写同一数据时可能会发生线程问题
- 安全性：
    - 数据竞争：多个线程会同时读写同一数据
    - 竞态条件：程序的执行结果依赖线程执行的顺序
- 活跃性：
    - 死锁
    - 活锁：线程没有发生阻塞，但仍然执行不下去
        - 解决方式：随机等待一个时间，比如Raft算法
    - 饥饿：线程因无法访问所需资源而无法执行下去
        - 保证资源充足
        - 公平地分配资源
        - 避免持有锁的线程长时间执行
- 性能问题：锁的过度使用可能导致串行化的范围过大，不能发挥多线程的优势
    - 使用无锁的算法和数据结构
    - 减少锁持有的时间
- 性能方面的度量指标：吞吐量、延迟和并发量


### 管程

- 管程是解决并发问题的万能钥匙
- 管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。
- MESA 模型：在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。
![image](http://cdn.standbyside.com/geektime/mesa-model.png)
- 管程如何解决互斥：将共享变量及其对共享变量的操作统一封装起来
- 管程如何解决同步：类似就医流程，使用条件变量和等待队列
- 对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 wait()。这个是 MESA 管程特有的。当线程 T2 的操作使线程 T1 等待的条件满足时，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。
```java
while (条件不满足) {
    wait();
}
```
- MESA 模型中，条件变量可以有多个；Java 语言内置的管程（synchronized）里只有一个条件变量，编译期会自动加锁解锁；Java SDK 并发包实现的管程支持多个条件变量，不过需要自己加锁解锁。

### 线程的生命周期与状态

- 通用的线程生命周期：
    - **初始状态**：线程已经被创建，但是还不允许分配 CPU 执行
    - **可运行状态**：线程可以分配 CPU 执行
    - **运行状态**：被分配到 CPU
    - **休眠状态**：调用一个阻塞的 API 或者等待某个事时，状态会转换到休眠状态，同时释放 CPU，直到等待的事件出现
    - **终止状态**：线程执行完或者出现异常
- Java 中线程的生命周期：
    - **NEW（初始化状态）**
    - **RUNNABLE（可运行 / 运行状态）**
    - **BLOCKED（阻塞状态，对应休眠）**
        - 线程等待 synchronized 的隐式锁
    - **WAITING（无时限等待，对应休眠）**
        - 获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法
        - 调用无参数的 Thread.join() 方法
        - 调用 LockSupport.park() 方法
    - **TIMED_WAITING（有时限等待，对应休眠）**
        -  调用带超时参数的 Thread.sleep(long millis) 方法；
        -  获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法；
        -  调用带超时参数的 Thread.join(long millis) 方法；
        -  调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；
        -  调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。
    - **TERMINATED（终止状态）**
- 想要终止`run()`执行，应该使用`interrupt()`，不要使用`stop()`、`suspend()`、`resume()`
- 可以通过 jstack 命令或者 Java VisualVM 将 JVM 所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。

### 多线程的应用场景

- 在并发编程领域，提升性能本质上就是提升硬件的利用率，就是提升 I/O 的利用率和 CPU 的利用率。
- 如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来提高吞吐量。
- 创建多少线程合适
    - 对于 CPU 密集型，理论上"线程的数量  = CPU 核数"就是最合适的。不过在工程上，线程的数量一般会设置为"CPU 核数 + 1"
    - 对于 I/O 密集型，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的，单核时最佳线程数 = 1 +（I/O 耗时 / CPU 耗时），多核时 = CPU核数 * 单线程最佳线程数
- 最佳线程数最终还是靠压测来确定的，实际工作中"I/O 耗时 / CPU 耗时"往往都大于 1，所以基本上都是在这个初始值的基础上增加。增加的过程中，应关注线程数是如何影响吞吐量和延迟的。一般来讲，随着线程数的增加，吞吐量会增加，延迟也会缓慢增加；但是当线程数增加到一定程度，吞吐量就会开始下降，延迟会迅速增加。这个时候基本上就是线程能够设置的最大值了。不同的 I/O 模型对最佳线程数的影响也非常大。

### 用面向对象思想写好并发程序

- 将共享变量作为对象属性封装在内部，对所有公共方法制定并发访问策略。
- 对于不会发生变化的共享变量，建议用 final 关键字来修饰。
- 识别出所有共享变量之间的约束条件（注意 if 条件）
- 制定并发访问策略
    - 避免共享
    - 不变模式
    - 管程及其他同步工具
- 宏观的原则
    - **优先使用成熟的工具类**：Java SDK 并发包里提供了丰富的工具类
    - **迫不得已时才使用低级的同步原语**：主要指的是 synchronized、Lock、Semaphore 等
    - **避免过早优化**：并发程序首先要保证安全，出现性能瓶颈后再优化


<br/><br/>注：以上内容摘自 [极客时间《Java并发编程实战》](https://time.geekbang.org/column/intro/100023901)

